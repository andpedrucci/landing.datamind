<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>PCB Procedural – grow from empty</title>
<style>
  :root{
    /* janelas de tempo (ajuste à vontade) */
    --min-dur: 10s;   /* duração mínima da animação de cada trilha */
    --max-dur: 22s;   /* duração máxima da animação de cada trilha */
    --build-window: 26s; /* atraso máx. para escalonar o início (stagger) */
  }

  html, body {
    height:100%;
    margin:0;
    background:#0a0f0d;
    overflow:hidden;
  }
  svg#pcb {
    width:100vw;
    height:100vh;
    display:block;
  }

  .trace{
    stroke:#1ec9b8;
    fill:none;
    stroke-linecap:round;
    stroke-linejoin:round;
    filter:drop-shadow(0 0 6px rgba(30,201,184,.75));
    will-change: stroke-dashoffset, opacity;
    shape-rendering:geometricPrecision;
  }

  /* cresce e FICA desenhado (sem piscar) */
  .trace.grow {
  stroke-dasharray: var(--len);
  stroke-dashoffset: var(--len);
  animation: growHold var(--dur, 16s) linear var(--delay, 0s) forwards;
}

@keyframes growHold {
  0%   { stroke-dashoffset: var(--len); opacity:0; }
  10%  { opacity:1; }
  100% { stroke-dashoffset: 0; opacity:1; }  /* nunca volta pra 0 de opacidade */
}

  /* se quiser looping depois, troque 'grow' por 'loop' no JS */
  .trace.loop {
    stroke-dasharray: var(--len);
    stroke-dashoffset: var(--len);
    animation: growLoop var(--dur, 16s) linear var(--delay, 0s) infinite;
  }

  @keyframes growHold {
    0%   { stroke-dashoffset: var(--len); opacity:0; }
    10%  { opacity:1; }
    100% { stroke-dashoffset: 0; opacity:1; }
  }

  @keyframes growLoop {
    0%   { stroke-dashoffset: var(--len); opacity:0; }
    12%  { opacity:1; }
    60%  { stroke-dashoffset: 0; opacity:1; }
    100% { stroke-dashoffset: 0; opacity:0; }
  }

  .pad{
    fill:#0a0f0d;
    stroke:#1ec9b8;
    stroke-width:2;
    filter:drop-shadow(0 0 6px rgba(30,201,184,.9));
  }
  .chip{
    fill:none;
    stroke:#1ec9b8;
    filter:drop-shadow(0 0 6px rgba(30,201,184,.85));
  }
</style>
</head>
<body>
  <svg id="pcb"></svg>

<script>
(function () {
  /* ====================== PARÂMETROS ====================== */
  const NUM_TRACES   = 220;  // densidade de trilhas
  const NUM_PADS     = 90;
  const NUM_CHIPS    = 18;

  const STEP         = 44;   // tamanho da malha (maior = quadrados maiores)
  const MIN_SEGS     = 22;   // segmentos por trilha (comprimento)
  const MAX_SEGS     = 52;

  const DIAG_PROB    = 0.22; // probabilidade de escolher 45° (mistura com 90°)
  const LONG_RUN_P   = 0.55; // prob. de “avenida longa” na mesma direção
  const LONG_RUN_MIN = 3;
  const LONG_RUN_MAX = 8;

  const LOOP         = false; // FALSE = cresce e fica / TRUE = cresce, some e reinicia

  /* ====================== SETUP SVG ====================== */
  const svg = document.getElementById('pcb');
  const W = window.innerWidth;
  const H = window.innerHeight;
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

  /* ====================== HELPERS ====================== */
  const rnd   = (a,b)=>Math.random()*(b-a)+a;
  const rndi  = (a,b)=>Math.floor(rnd(a,b+1));
  const clamp = (x,min,max)=> x<min?min: x>max?max: x;

  const DIRS90 = [[1,0],[-1,0],[0,1],[0,-1]];
  const DIRS45 = [[1,1],[-1,1],[1,-1],[-1,-1]];
  const pick90 = ()=>DIRS90[Math.floor(Math.random()*DIRS90.length)];
  const pick45 = ()=>DIRS45[Math.floor(Math.random()*DIRS45.length)];

  const gx = v => Math.floor(v/STEP)*STEP;
  const gy = v => Math.floor(v/STEP)*STEP;

  function buildPath(x0, y0, segs){
    let x = gx(x0), y = gy(y0);
    let d = `M${x} ${y}`;
    let runLeft = 0;
    let dir = pick90();

    for (let i=0;i<segs;i++){
      if (runLeft<=0){
        dir = (Math.random()<DIAG_PROB) ? pick45() : pick90();
        runLeft = (Math.random()<LONG_RUN_P) ? rndi(LONG_RUN_MIN, LONG_RUN_MAX) : 1;
      }
      runLeft--;

      x += dir[0]*STEP;
      y += dir[1]*STEP;
      x = clamp(x, 0, W);
      y = clamp(y, 0, H);
      d += ` L${x} ${y}`;
    }
    return d;
  }

  function addPath(d, animate=true){
    const p = document.createElementNS('http://www.w3.org/2000/svg','path');
    p.setAttribute('d', d);
    p.setAttribute('class', 'trace');

    // espessuras variadas
    const sw = Math.random()<.22 ? 3.2 : (Math.random()<.6 ? 2 : 1.4);
    p.style.strokeWidth = sw;
    svg.appendChild(p);

    // comprimento real e animação escalonada
    const len = p.getTotalLength() || 1;
    const minDur   = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--min-dur')) || 10;
    const maxDur   = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-dur')) || 22;
    const buildWin = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--build-window')) || 26;

    p.style.setProperty('--len', len);
    if (animate){
      const dur   = rnd(minDur, maxDur).toFixed(2)+'s';
      const delay = rnd(0, buildWin).toFixed(2)+'s';
      p.style.setProperty('--dur', dur);
      p.style.setProperty('--delay', delay);
      p.classList.add(LOOP ? 'loop' : 'grow'); // decide o tipo
    } else {
      // se algum dia quiser trilha estática desde o começo:
      p.style.strokeDasharray = len;
      p.style.strokeDashoffset = len; // começa escondida
      // e pode animar depois via JS se precisar
    }
    return p;
  }

  /* ====================== GERAÇÃO ====================== */
  for (let i=0;i<NUM_TRACES;i++){
    const d = buildPath(Math.random()*W, Math.random()*H, rndi(MIN_SEGS, MAX_SEGS));
    addPath(d, true); // todas animam (começa VAZIO e vai preenchendo)
  }

  for (let i=0;i<NUM_PADS;i++){
    const cx = gx(Math.random()*W);
    const cy = gy(Math.random()*H);
    const pad = document.createElementNS('http://www.w3.org/2000/svg','circle');
    pad.setAttribute('cx', cx);
    pad.setAttribute('cy', cy);
    pad.setAttribute('r', Math.random()<.25 ? 6 : 4);
    pad.setAttribute('class','pad');
    svg.appendChild(pad);
  }

  for (let i=0;i<NUM_CHIPS;i++){
    const x = gx(Math.random()*(W-120));
    const y = gy(Math.random()*(H-120));
    const chip = document.createElementNS('http://www.w3.org/2000/svg','rect');
    chip.setAttribute('x', x);
    chip.setAttribute('y', y);
    chip.setAttribute('width',  40 + Math.random()*120);
    chip.setAttribute('height', 40 + Math.random()*120);
    chip.setAttribute('class','chip');
    chip.style.strokeWidth = Math.random()<.5 ? 2.5 : 4;
    svg.appendChild(chip);
  }
})();
</script>
</body>
</html>
